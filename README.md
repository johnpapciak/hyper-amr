# Multimodal Hyperbolic AMR

### Hyperbolic multimodal representation learning for hierarchical detection of antimicrobial-resistance (AMR) genes and microbial taxa in metagenomic data.

---

## Overview
This project explores **Hyperbolic Multimodal Representation Learning (HMRL)** for the detection and characterization of antimicrobial-resistance (AMR) genes from metagenomic sequencing data.
By embedding **DNA sequence features**, **AMR gene annotations**, and **taxonomic hierarchies** into a shared **hyperbolic space**, the model aims to preserve biological hierarchy and improve generalization across microbial lineages.

This approach combines deep sequence encoders with hyperbolic geometry to enable probabilistic inference of AMR potential, particularly for novel or under-annotated species.

---

## Project Motivation
Traditional machine learning models treat taxonomic labels as flat, independent categories, ignoring their hierarchical structure. However, microbial taxonomy expands exponentially from phylum to strain.
**Hyperbolic space**, with its exponential geometry, provides a natural representation for such biological trees.

By learning a **shared hyperbolic embedding** of sequence, function, and taxonomy, we can:
- Capture **hierarchical relationships** among taxa and AMR gene families.
- Infer **AMR potential** for uncharacterized or novel organisms.
- Enable **joint prediction** of host taxon and associated AMR genes.

---

## Methods

### Inputs
1. **Sequence embeddings** — contig-level representations (1–10 kb) generated by CNN or k-mer Transformer encoders.
2. **AMR gene features** — multi-hot or coverage-based vectors derived from curated databases (CARD, ResFinder).
3. **Taxonomic embeddings** — hierarchical node vectors representing species, genus, and family relationships.

### Model
- Projects all three modalities into a shared **Poincaré-ball hyperbolic manifold**.
- Optimizes three loss components:
  - **Alignment loss (contrastive/InfoNCE):** pulls true sequence–AMR–taxon triplets together.
  - **Stacked entailment loss:** enforces hierarchical structure among taxonomic ancestors.
  - **Optional supervised loss:** for AMR presence classification.

### Outputs
- Predicted **taxonomic identity** of contigs.
- Predicted **probability of AMR gene presence**.

---

## Data
- **AMR Databases:** CARD, ResFinder
- **Taxonomy Source:** NCBI RefSeq genomes
- **Benchmarking:** CAMI metagenomic datasets
- ~100,000 contigs (≈30k AMR-positive, 70k negatives)
- Stratified 70/15/15 splits with genus/species-exclusive partitions for hierarchical generalization testing.

---

## Evaluation
Performance will be compared against:
- **Taxonomy tools:** Kraken2, Bracken
- **AMR tools:** AMRFinder Plus, ResFinder
- **Model ablations:** Euclidean multimodal and unimodal (sequence-only) baselines

### Metrics
- **AUPR / AUROC:** for AMR detection
- **Hierarchical accuracy:** for taxonomic prediction
- **Joint AMR–Taxon F1:** for functional–evolutionary consistency
- **Open-set and low-abundance tests:** for robustness

Uncertainty may be estimated using bootstrap resampling over test contigs.

---

## Notebook -> CLI pipeline

The exploratory processing in `amr_eda.ipynb` has been distilled into a small
Python package under `hyper_amr/` with an accompanying CLI. This makes it
easier to process multiple genomes, train the hyperbolic model, and regenerate
plots without re-running notebook cells.

### Installation

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

### Command overview

```bash
python -m hyper_amr.cli download --urls https://.../genome.fasta --output data/raw
python -m hyper_amr.cli run-amrfinder --fasta data/raw/genome.fasta --output data/amrfinder
python -m hyper_amr.cli subsample --tsvs data/amrfinder/genome.amrfinder.tsv --fastas data/raw/genome.fasta \
    --output data/subsampled --frac 0.1 --max-contigs 5000
python -m hyper_amr.cli prepare --tsvs data/amrfinder/genome.amrfinder.tsv \
    --fastas data/raw/genome.fasta --output data/artifacts
python -m hyper_amr.cli balance --artifacts data/artifacts --fastas data/raw/genome.fasta
python -m hyper_amr.cli train --artifacts data/artifacts --fastas data/raw/genome.fasta \
    --epochs 5 --k 5 --buckets 4096 --class-weights --hash-threads 4 --loader-workers 4
python -m hyper_amr.cli plot --artifacts data/artifacts
```

Key steps align with the notebook:
- **download**: optional helper to fetch FASTA genomes from URLs.
- **run-amrfinder**: execute AMRFinderPlus per FASTA (plus DB supported).
- **subsample**: downsample FASTA/TSV pairs (by fraction or count) without re-running
  AMRFinder to create lighter test datasets.
  You can run this before `prepare` to shrink large genomes; set `--frac` or
  `--num-contigs` globally and optionally cap per-file size with `--max-contigs`
  so oversized FASTAs are reduced more aggressively than smaller ones.

- **prepare**: build contig-level AMR labels, attach sequences, and store
  `contig_amr_labels.parquet` + `amr_class_list.json` artifacts.
- **balance**: inspect AMR class balance per source FASTA (saves
  `label_balance_by_source.csv`) to validate label coverage before training.
- **train**: hash sequences into k-mer buckets, configure hyperbolic geometry
  in pure PyTorch, and train/evaluate the joint sequence–AMR model. Optional
  taxonomy embeddings can be toggled with `--use-taxonomy`. For hierarchical
  supervision, pass lineage columns with `--taxonomy-cols phylum,class,order,family,genus,species`; the
  model embeds each rank and applies a radial entailment loss along the
  lineage. Feature hashing and PyTorch DataLoader construction now support multi-threading via
  `--hash-threads` and `--loader-workers`.
- **plot**: generate AMR class frequency and precision–recall plots from saved
  predictions (`predictions.npz`).